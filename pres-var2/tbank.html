<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Евгений Чебатков. Коммерческое предложение для Т-Банка</title>
  <style>
    :root {
      --aspect-ratio: 1.7777778;
      --stage-gap: 14px;
      --text: #f0f1f3;
      --panel: rgba(17, 20, 24, 0.72);
      --panel-border: rgba(255, 255, 255, 0.16);
      --move-distance: 100px;
      --stagger: 220ms;
      --anim-duration: 1040ms;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      min-width: 100%;
      min-height: 100%;
      overflow: hidden;
      color: var(--text);
      font-family: "Segoe UI", "Trebuchet MS", sans-serif;
      background-color: #06080c;
      background:
        radial-gradient(90vw 90vh at 15% 15%, #23262b 0%, rgba(35, 38, 43, 0) 65%),
        radial-gradient(80vw 80vh at 85% 85%, #2a2a2a 0%, rgba(42, 42, 42, 0) 60%),
        #06080c;
    }

    body {
      min-width: 100vw;
      min-height: 100vh;
      min-width: 100dvw;
      min-height: 100dvh;
      overscroll-behavior: none;
    }

    #app {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      width: 100dvw;
      height: 100dvh;
      display: grid;
      place-items: center;
      padding: 0;
    }

    #stage-wrap {
      position: relative;
      width: min(
        calc(100vw - (var(--stage-gap) * 2)),
        calc((100vh - (var(--stage-gap) * 2)) * var(--aspect-ratio))
      );
      height: min(
        calc(100vh - (var(--stage-gap) * 2)),
        calc((100vw - (var(--stage-gap) * 2)) / var(--aspect-ratio))
      );
      width: min(
        calc(100dvw - (var(--stage-gap) * 2)),
        calc((100dvh - (var(--stage-gap) * 2)) * var(--aspect-ratio))
      );
      height: min(
        calc(100dvh - (var(--stage-gap) * 2)),
        calc((100dvw - (var(--stage-gap) * 2)) / var(--aspect-ratio))
      );
      border-radius: 14px;
      overflow: hidden;
      background: #000;
      box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.55),
        inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #stage {
      position: absolute;
      inset: 0;
      isolation: isolate;
    }

    .layer {
      position: absolute;
      left: 0;
      top: 0;
      max-width: none;
      max-height: none;
      opacity: 0;
      transform: translate3d(0, 0, 0);
      will-change: opacity, transform;
      pointer-events: none;
      user-select: none;
    }

    #pager {
      position: absolute;
      left: 50%;
      bottom: 12px;
      bottom: max(12px, env(safe-area-inset-bottom));
      transform: translateX(-50%);
      z-index: 9000;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      background: rgba(17, 20, 24, 0.62);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(8px);
      cursor: default;
      opacity: 0;
      pointer-events: none;
      transition: opacity 140ms ease;
    }

    #pager.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .pager-dot {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1.5px solid rgba(255, 255, 255, 0.9);
      background: transparent;
      padding: 0;
      cursor: default;
    }

    .pager-dot.active {
      background: rgba(255, 255, 255, 0.95);
    }

    .pager-dot:focus-visible {
      outline: 2px solid rgba(255, 255, 255, 0.9);
      outline-offset: 2px;
    }

    #swipe-hint {
      position: absolute;
      inset: 0;
      z-index: 9500;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;
    }

    #swipe-hint.visible {
      opacity: 1;
    }

    #swipe-hint-dot {
      position: absolute;
      left: 50%;
      top: 54%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.24);
      border: 1.5px solid rgba(255, 255, 255, 0.72);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateX(88px) scale(0.95);
    }

    #swipe-hint.visible #swipe-hint-dot {
      animation: swipe-hint-dot 2200ms cubic-bezier(0.2, 0.8, 0.2, 1) 1 both;
    }

    #download-pdf-wrap {
      position: fixed;
      top: max(12px, env(safe-area-inset-top));
      right: max(12px, env(safe-area-inset-right));
      z-index: 9700;
    }

    #download-pdf {
      padding: 10px 14px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      border-radius: 10px;
      background: rgba(17, 20, 24, 0.72);
      color: #f0f1f3;
      font: 600 14px/1 "Segoe UI", "Trebuchet MS", sans-serif;
      cursor: pointer;
      backdrop-filter: blur(8px);
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
      transition: opacity 140ms ease, transform 140ms ease;
    }

    #download-pdf-wrap:hover #download-pdf,
    #download-pdf:focus-visible,
    #download-pdf[data-busy="true"] {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    #download-pdf:hover {
      transform: translateY(-1px);
    }

    #download-pdf:disabled {
      opacity: 0.66;
      cursor: progress;
      transform: none;
    }

    @keyframes swipe-hint-dot {
      0% {
        opacity: 0;
        transform: translateX(88px) scale(0.95);
      }
      22% {
        opacity: 0.76;
        transform: translateX(88px) scale(1);
      }
      70% {
        opacity: 0.72;
        transform: translateX(-88px) scale(1);
      }
      90% {
        opacity: 0.56;
        transform: translateX(-88px) scale(0.98);
      }
      100% {
        opacity: 0;
        transform: translateX(-88px) scale(0.95);
      }
    }

    #loading,
    #error {
      position: absolute;
      inset: 0;
      z-index: 10000;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      font-size: clamp(16px, 2vw, 24px);
      background: linear-gradient(120deg, rgba(7, 10, 14, 0.95), rgba(12, 17, 20, 0.85));
    }

    #loading.hidden,
    #error.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <main id="app">
    <div id="download-pdf-wrap">
      <button id="download-pdf" type="button">Скачать PDF</button>
    </div>
    <section id="stage-wrap" aria-label="presentation stage">
      <div id="loading">Загрузка изображений...</div>
      <div id="error" class="hidden"></div>
      <div id="stage"></div>
      <div id="pager" aria-label="slide pages"></div>
      <div id="swipe-hint" aria-hidden="true"><div id="swipe-hint-dot"></div></div>
    </section>
  </main>

  <script src="./tbank-image-files.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
    const IMAGE_FILES = Array.isArray(window.TBANK_IMAGE_FILES) ? window.TBANK_IMAGE_FILES : [];
    const META_RE = /slide-(\d+)-(\d+)(?:-([a-z]+))?-IN-([a-z]+)-OUT-([a-z]+)/i;
    const SIZE_RE = /-(\d+)x(\d+)-slide-/i;
    const POSITION_RE = /-X(-?\d+)-Y(-?\d+)$/i;
    const DEFAULT_STAGE_SIZE = Object.freeze({
      WIDTH: 3840,
      HEIGHT: 2160
    });

    const MOVE_DISTANCE = 100;

    // Fixed timing values. Edit these four numbers if you need to retune animations.
    const ANIMATION_TIMING = Object.freeze({
      IN_DURATION_MS: 2000,
      IN_START_DELAY_MS: 200,
      OUT_DURATION_MS: 500,
      OUT_START_DELAY_MS: 50
    });
    const SWIPE_SETTINGS = Object.freeze({
      MIN_DISTANCE_PX: 42,
      MAX_OFF_AXIS_PX: 90,
      MAX_DURATION_MS: 700,
      SUPPRESS_CLICK_MS: 420
    });
    const SWIPE_HINT_SETTINGS = Object.freeze({
      INITIAL_DELAY_MS: 1200,
      DURATION_MS: 2200
    });
    const PRELOAD_SETTINGS = Object.freeze({
      MAX_RETRIES: 4,
      RETRY_DELAY_MS: 280,
      CONCURRENCY: 6,
      TIMEOUT_MS: 12000
    });
    const HAS_TOUCH_INPUT = window.matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;

    const stageWrap = document.getElementById("stage-wrap");
    const stage = document.getElementById("stage");
    const pagerNode = document.getElementById("pager");
    const swipeHintNode = document.getElementById("swipe-hint");
    const downloadPdfButton = document.getElementById("download-pdf");
    const loadingNode = document.getElementById("loading");
    const errorNode = document.getElementById("error");

    let slides = [];
    let currentSlideIndex = 0;
    let requestedSlideIndex = 0;
    let activeLayers = [];
    let isTransitioning = false;
    let swipeHintTimeoutId = null;
    let touchSwipeStart = null;
    let suppressClickUntilTs = 0;
    let isExportingPdf = false;
    const pdfImageCache = new Map();

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function setAspectRatio(width, height) {
      if (!width || !height) return;
      stageWrap.style.setProperty("--aspect-ratio", String(width / height));
    }

    function toPercent(value, total) {
      if (!Number.isFinite(value) || !Number.isFinite(total) || total === 0) {
        return "0%";
      }
      return `${(value / total) * 100}%`;
    }

    function normalizeDiscoveredPath(path) {
      const raw = decodeURIComponent(String(path || "")).replace(/\\/g, "/").replace(/^\.\//, "");
      if (raw.startsWith("http://") || raw.startsWith("https://")) {
        try {
          const url = new URL(raw);
          return url.pathname.replace(/^\/+/, "");
        } catch {
          return raw;
        }
      }

      let clean = raw.replace(/^\/+/, "");
      const nestedImgMatch = clean.match(/(?:^|\/)(img\/.+)$/i);
      if (nestedImgMatch) {
        clean = nestedImgMatch[1];
      }

      if (clean.startsWith("img/")) {
        return clean;
      }
      return `img/${clean.replace(/^\/+/, "")}`;
    }

    function normalizeDirection(direction, fallback) {
      const value = String(direction || fallback).toLowerCase();
      if (value === "top") return "up";
      if (value === "bottom") return "down";
      return value;
    }

    function normalizeBlendMode(value) {
      const mode = String(value || "").toLowerCase();
      if (mode === "screen") return "screen";
      return "normal";
    }

    function moveInVector(direction) {
      switch (normalizeDirection(direction, "left")) {
        case "left":
          return [MOVE_DISTANCE, 0];
        case "right":
          return [-MOVE_DISTANCE, 0];
        case "up":
          return [0, MOVE_DISTANCE];
        case "down":
          return [0, -MOVE_DISTANCE];
        case "static":
          return [0, 0];
        default:
          return [MOVE_DISTANCE, 0];
      }
    }

    function moveOutVector(direction) {
      switch (normalizeDirection(direction, "right")) {
        case "left":
          return [-MOVE_DISTANCE, 0];
        case "right":
          return [MOVE_DISTANCE, 0];
        case "up":
          return [0, -MOVE_DISTANCE];
        case "down":
          return [0, MOVE_DISTANCE];
        case "static":
          return [0, 0];
        default:
          return [MOVE_DISTANCE, 0];
      }
    }

    function parseMeta(path, layerSizeByPath) {
      const full = normalizeDiscoveredPath(path);
      const fileName = full.split("/").pop() || "";
      const baseName = fileName.replace(/\.[^.]+$/, "");
      const match = baseName.match(META_RE);
      if (!match) return null;

      const size = baseName.match(SIZE_RE);
      const position = baseName.match(POSITION_RE);
      const layerSize = layerSizeByPath instanceof Map ? layerSizeByPath.get(full) : null;
      const stageWidth = size ? Number(size[1]) : DEFAULT_STAGE_SIZE.WIDTH;
      const stageHeight = size ? Number(size[2]) : DEFAULT_STAGE_SIZE.HEIGHT;
      return {
        src: `./${full}`,
        slide: Number(match[1]),
        layer: Number(match[2]),
        blendMode: normalizeBlendMode(match[3]),
        inDir: String(match[4]).toLowerCase(),
        outDir: String(match[5]).toLowerCase(),
        x: position ? Number(position[1]) : 0,
        y: position ? Number(position[2]) : 0,
        stageWidth,
        stageHeight,
        layerWidth: layerSize?.width ?? stageWidth,
        layerHeight: layerSize?.height ?? stageHeight,
        fileName
      };
    }

    function buildSlides(paths, layerSizeByPath) {
      const parsed = paths.map((path) => parseMeta(path, layerSizeByPath)).filter(Boolean);
      if (!parsed.length) {
        throw new Error("Не удалось найти изображения формата *-slide-XX-YY-(MODE)-IN-*-OUT-*-X*-Y* в папке img.");
      }

      const withSize = parsed.find((item) => item.stageWidth && item.stageHeight);
      if (withSize) {
        setAspectRatio(withSize.stageWidth, withSize.stageHeight);
      } else {
        setAspectRatio(DEFAULT_STAGE_SIZE.WIDTH, DEFAULT_STAGE_SIZE.HEIGHT);
      }

      const grouped = new Map();
      for (const layer of parsed) {
        if (!grouped.has(layer.slide)) {
          grouped.set(layer.slide, []);
        }
        grouped.get(layer.slide).push(layer);
      }

      return [...grouped.entries()]
        .sort((a, b) => a[0] - b[0])
        .map(([slideNumber, layers]) => ({
          slideNumber,
          layers: layers.sort((a, b) => a.layer - b.layer)
        }));
    }

    async function discoverImageFiles() {
      return IMAGE_FILES.map(normalizeDiscoveredPath);
    }

    function buildRetrySrc(src, attempt) {
      if (attempt <= 1) return src;
      const separator = src.includes("?") ? "&" : "?";
      return `${src}${separator}retry=${attempt}-${Date.now()}`;
    }

    function loadImageOnce(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        let timeoutId = null;

        const cleanup = () => {
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          img.onload = null;
          img.onerror = null;
        };

        img.onload = () => {
          cleanup();
          resolve({
            width: img.naturalWidth || img.width,
            height: img.naturalHeight || img.height
          });
        };
        img.onerror = () => {
          cleanup();
          reject(new Error(`Ошибка загрузки: ${src}`));
        };

        timeoutId = setTimeout(() => {
          cleanup();
          reject(new Error(`Таймаут загрузки: ${src}`));
        }, PRELOAD_SETTINGS.TIMEOUT_MS);

        img.src = src;
      });
    }

    async function loadImageWithRetry(path) {
      const baseSrc = `./${path}`;
      let lastError = null;

      for (let attempt = 1; attempt <= PRELOAD_SETTINGS.MAX_RETRIES; attempt += 1) {
        try {
          return await loadImageOnce(buildRetrySrc(baseSrc, attempt));
        } catch (error) {
          lastError = error;
          if (attempt < PRELOAD_SETTINGS.MAX_RETRIES) {
            await sleep(PRELOAD_SETTINGS.RETRY_DELAY_MS * attempt);
          }
        }
      }

      const isTimeout = lastError instanceof Error && lastError.message.startsWith("Таймаут загрузки:");
      const message = isTimeout ? `Таймаут загрузки: ${baseSrc}` : `Ошибка загрузки: ${baseSrc}`;
      throw new Error(
        `${message} (после ${PRELOAD_SETTINGS.MAX_RETRIES} попыток)`
      );
    }

    async function preloadImages(paths) {
      const unique = [...new Set(paths.map(normalizeDiscoveredPath))];
      const layerSizeByPath = new Map();
      let loaded = 0;
      let nextIndex = 0;

      async function worker() {
        while (nextIndex < unique.length) {
          const current = nextIndex;
          nextIndex += 1;
          const path = unique[current];
          const layerSize = await loadImageWithRetry(path);
          layerSizeByPath.set(path, layerSize);
          loaded += 1;
          loadingNode.textContent = `Загрузка изображений... ${loaded}/${unique.length}`;
        }
      }

      const workerCount = Math.max(1, Math.min(PRELOAD_SETTINGS.CONCURRENCY, unique.length));
      const workers = Array.from({ length: workerCount }, () => worker());
      await Promise.all(workers);
      return layerSizeByPath;
    }

    function createLayer(meta) {
      const img = document.createElement("img");
      img.className = "layer";
      img.src = meta.src;
      img.alt = meta.fileName;
      img.style.left = toPercent(meta.x, meta.stageWidth);
      img.style.top = toPercent(meta.y, meta.stageHeight);
      img.style.width = toPercent(meta.layerWidth, meta.stageWidth);
      img.style.height = toPercent(meta.layerHeight, meta.stageHeight);
      img.style.mixBlendMode = meta.blendMode === "screen" ? "screen" : "normal";
      img.style.zIndex = String(100000 - meta.layer);
      return { meta, el: img };
    }

    function cancelElementAnimations(el) {
      el.getAnimations().forEach((anim) => anim.cancel());
    }

    function hideSwipeHint() {
      if (swipeHintTimeoutId !== null) {
        clearTimeout(swipeHintTimeoutId);
        swipeHintTimeoutId = null;
      }
      swipeHintNode.classList.remove("visible");
    }

    function showSwipeHintOnce() {
      if (!HAS_TOUCH_INPUT) return;
      swipeHintNode.classList.remove("visible");
      // Restart animation if the class was just removed.
      void swipeHintNode.offsetWidth;
      swipeHintNode.classList.add("visible");
      if (swipeHintTimeoutId !== null) {
        clearTimeout(swipeHintTimeoutId);
      }
      swipeHintTimeoutId = setTimeout(() => {
        swipeHintNode.classList.remove("visible");
        swipeHintTimeoutId = null;
      }, SWIPE_HINT_SETTINGS.DURATION_MS + 100);
    }

    function updatePagerActive() {
      const dots = pagerNode.querySelectorAll(".pager-dot");
      dots.forEach((dot, index) => {
        const isActive = index === requestedSlideIndex;
        dot.classList.toggle("active", isActive);
        dot.setAttribute("aria-current", isActive ? "true" : "false");
      });
    }

    function renderPager() {
      pagerNode.textContent = "";
      const fragment = document.createDocumentFragment();
      slides.forEach((slide, index) => {
        const dot = document.createElement("button");
        dot.type = "button";
        dot.className = "pager-dot";
        dot.dataset.index = String(index);
        dot.title = `Слайд ${slide.slideNumber}`;
        dot.setAttribute("aria-label", `Перейти на слайд ${slide.slideNumber}`);
        fragment.appendChild(dot);
      });
      pagerNode.appendChild(fragment);
      updatePagerActive();
    }

    async function animateIn(entry) {
      cancelElementAnimations(entry.el);
      const [x, y] = moveInVector(entry.meta.inDir);
      const anim = entry.el.animate(
        [
          { opacity: 0, transform: `translate3d(${x}px, ${y}px, 0)` },
          { opacity: 1, transform: "translate3d(0, 0, 0)" }
        ],
        {
          duration: ANIMATION_TIMING.IN_DURATION_MS,
          easing: "cubic-bezier(0.22, 1, 0.36, 1)",
          fill: "forwards"
        }
      );
      await anim.finished.catch(() => {});
    }

    async function animateOut(entry) {
      const computed = getComputedStyle(entry.el);
      const fromOpacity = computed.opacity || "1";
      const fromTransform = computed.transform === "none"
        ? "translate3d(0, 0, 0)"
        : computed.transform;
      cancelElementAnimations(entry.el);
      const [x, y] = moveOutVector(entry.meta.outDir);
      const anim = entry.el.animate(
        [
          { opacity: fromOpacity, transform: fromTransform },
          { opacity: 0, transform: `translate3d(${x}px, ${y}px, 0)` }
        ],
        {
          duration: ANIMATION_TIMING.OUT_DURATION_MS,
          easing: "cubic-bezier(0.55, 0.08, 0.68, 0.53)",
          fill: "forwards"
        }
      );
      await anim.finished.catch(() => {});
      entry.el.remove();
    }

    async function showSlide(slide) {
      const orderFromBottom = [...slide.layers].sort((a, b) => b.layer - a.layer);
      const entries = orderFromBottom.map(createLayer);
      const staggerMs = ANIMATION_TIMING.IN_START_DELAY_MS;

      for (const entry of entries) {
        stage.appendChild(entry.el);
      }

      // Mark slide layers as active before animations finish, so hide logic
      // always has the full current set.
      activeLayers = entries;

      return Promise.all(
        entries.map((entry, index) =>
          sleep(index * staggerMs).then(() => animateIn(entry))
        )
      );
    }

    async function hideActiveSlide() {
      const orderFromBottom = [...activeLayers].sort((a, b) => b.meta.layer - a.meta.layer);
      const staggerMs = ANIMATION_TIMING.OUT_START_DELAY_MS;
      await Promise.all(
        orderFromBottom.map((entry, index) =>
          sleep(index * staggerMs).then(() => animateOut(entry))
        )
      );
      activeLayers = [];
    }

    async function goToSlide(targetIndex) {
      if (!slides.length) return;

      const clampedTarget = Math.max(0, Math.min(targetIndex, slides.length - 1));
      requestedSlideIndex = clampedTarget;
      hideSwipeHint();
      updatePagerActive();

      if (isTransitioning) return;

      isTransitioning = true;
      try {
        while (requestedSlideIndex !== currentSlideIndex) {
          await hideActiveSlide();
          currentSlideIndex = requestedSlideIndex;
          void showSlide(slides[currentSlideIndex]);
        }
      } finally {
        isTransitioning = false;
      }
    }

    async function goNextSlide() {
      await goToSlide(requestedSlideIndex + 1);
    }

    async function goPrevSlide() {
      await goToSlide(requestedSlideIndex - 1);
    }

    function showError(message) {
      loadingNode.classList.add("hidden");
      errorNode.textContent = message;
      errorNode.classList.remove("hidden");
    }

    function setPdfButtonState(text, disabled, isBusy) {
      if (!(downloadPdfButton instanceof HTMLButtonElement)) return;
      downloadPdfButton.textContent = text;
      downloadPdfButton.disabled = disabled;
      if (isBusy) {
        downloadPdfButton.setAttribute("data-busy", "true");
      } else {
        downloadPdfButton.removeAttribute("data-busy");
      }
    }

    function getJsPdfCtor() {
      const maybeJspdf = window.jspdf;
      if (!maybeJspdf || typeof maybeJspdf.jsPDF !== "function") {
        return null;
      }
      return maybeJspdf.jsPDF;
    }

    function buildPdfFileNameFromTitle() {
      const rawTitle = String(document.title || "").trim();
      const sanitized = rawTitle.replace(/[\\/:*?"<>|\u0000-\u001F]/g, "").trim();
      if (!sanitized) {
        return "presentation.pdf";
      }
      return `${sanitized}.pdf`;
    }

    async function loadPdfImage(src) {
      if (pdfImageCache.has(src)) {
        return pdfImageCache.get(src);
      }

      const promise = new Promise((resolve, reject) => {
        const img = new Image();
        img.decoding = "async";
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Ошибка загрузки изображения для PDF: ${src}`));
        img.src = src;
      });
      pdfImageCache.set(src, promise);

      try {
        return await promise;
      } catch (error) {
        pdfImageCache.delete(src);
        throw error;
      }
    }

    function getSlideCanvasSize(slide) {
      if (!slide || !Array.isArray(slide.layers) || !slide.layers.length) {
        return { width: DEFAULT_STAGE_SIZE.WIDTH, height: DEFAULT_STAGE_SIZE.HEIGHT };
      }

      const sample = slide.layers[0];
      const width = Number.isFinite(sample.stageWidth) ? sample.stageWidth : DEFAULT_STAGE_SIZE.WIDTH;
      const height = Number.isFinite(sample.stageHeight) ? sample.stageHeight : DEFAULT_STAGE_SIZE.HEIGHT;
      return {
        width: Math.max(1, Math.round(width)),
        height: Math.max(1, Math.round(height))
      };
    }

    async function exportSlidesToPdf() {
      if (isExportingPdf) return;
      if (!slides.length) {
        window.alert("Слайды ещё не готовы.");
        return;
      }

      const JsPdfCtor = getJsPdfCtor();
      if (!JsPdfCtor) {
        window.alert("Не удалось загрузить библиотеку PDF. Проверьте доступ к интернету и попробуйте снова.");
        return;
      }

      isExportingPdf = true;
      setPdfButtonState("Генерация PDF...", true, true);

      try {
        const firstSize = getSlideCanvasSize(slides[0]);
        const isLandscape = firstSize.width >= firstSize.height;
        const pdf = new JsPdfCtor({
          orientation: isLandscape ? "landscape" : "portrait",
          unit: "px",
          format: [firstSize.width, firstSize.height],
          compress: true,
          hotfixes: ["px_scaling"]
        });

        const canvas = document.createElement("canvas");
        canvas.width = firstSize.width;
        canvas.height = firstSize.height;
        const ctx = canvas.getContext("2d", { alpha: false });
        if (!ctx) {
          throw new Error("Не удалось создать canvas для рендера PDF.");
        }

        for (let slideIndex = 0; slideIndex < slides.length; slideIndex += 1) {
          setPdfButtonState(`PDF: ${slideIndex + 1}/${slides.length}`, true, true);
          const slide = slides[slideIndex];
          const slideSize = getSlideCanvasSize(slide);

          if (slideSize.width !== canvas.width || slideSize.height !== canvas.height) {
            canvas.width = slideSize.width;
            canvas.height = slideSize.height;
          }

          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();

          const layersFromBottom = [...slide.layers].sort((a, b) => b.layer - a.layer);
          for (const layer of layersFromBottom) {
            const img = await loadPdfImage(layer.src);
            ctx.globalCompositeOperation = layer.blendMode === "screen" ? "screen" : "source-over";
            ctx.drawImage(img, layer.x, layer.y, layer.layerWidth, layer.layerHeight);
          }
          ctx.globalCompositeOperation = "source-over";

          const imageDataUrl = canvas.toDataURL("image/jpeg", 0.97);

          if (slideIndex > 0) {
            pdf.addPage([firstSize.width, firstSize.height], isLandscape ? "landscape" : "portrait");
          }
          pdf.addImage(
            imageDataUrl,
            "JPEG",
            0,
            0,
            firstSize.width,
            firstSize.height,
            undefined,
            "FAST"
          );

          // Give the browser a frame to paint progress text on the button.
          await sleep(0);
        }

        pdf.save(buildPdfFileNameFromTitle());
      } catch (error) {
        const message = error instanceof Error ? error.message : "Неизвестная ошибка";
        window.alert(`Не удалось сформировать PDF.\n\n${message}`);
      } finally {
        isExportingPdf = false;
        setPdfButtonState("Скачать PDF", false, false);
      }
    }

    async function start() {
      isTransitioning = true;
      try {
        const files = await discoverImageFiles();
        const layerSizeByPath = await preloadImages(files);
        slides = buildSlides(files, layerSizeByPath);
        if (!slides.length) {
          throw new Error("Слайды не найдены.");
        }

        currentSlideIndex = 0;
        requestedSlideIndex = 0;
        renderPager();
        loadingNode.classList.add("hidden");
        void showSlide(slides[currentSlideIndex]);
        setTimeout(() => {
          if (currentSlideIndex === 0 && requestedSlideIndex === 0 && !isTransitioning) {
            showSwipeHintOnce();
          }
        }, SWIPE_HINT_SETTINGS.INITIAL_DELAY_MS);
      } catch (error) {
        const message = error instanceof Error ? error.message : "Неизвестная ошибка";
        showError(
          `${message}\n\nЗапускайте страницу через локальный сервер (например: python -m http.server), если браузер блокирует чтение папки img.`
        );
      } finally {
        isTransitioning = false;
      }
    }

    document.addEventListener("keydown", (event) => {
      if (event.code === "Space" || event.code === "ArrowRight") {
        event.preventDefault();
        void goNextSlide();
        return;
      }
      if (event.code === "ArrowLeft") {
        event.preventDefault();
        void goPrevSlide();
      }
    });

    stageWrap.addEventListener("click", (event) => {
      if (Date.now() < suppressClickUntilTs) {
        return;
      }
      if (event.target instanceof Element && (event.target.closest("#pager") || event.target.closest("#download-pdf"))) {
        return;
      }
      const rect = stageWrap.getBoundingClientRect();
      const relativeX = event.clientX - rect.left;
      if (relativeX < rect.width / 2) {
        void goPrevSlide();
      } else {
        void goNextSlide();
      }
    });

    pagerNode.addEventListener("click", (event) => {
      const target = event.target instanceof Element ? event.target.closest(".pager-dot") : null;
      if (!(target instanceof HTMLElement)) return;
      event.stopPropagation();
      const index = Number(target.dataset.index);
      if (!Number.isFinite(index)) return;
      void goToSlide(index);
    });

    function onTouchStart(event) {
      if (event.target instanceof Element && event.target.closest("#pager")) {
        touchSwipeStart = null;
        return;
      }
      if (event.touches.length !== 1) {
        touchSwipeStart = null;
        return;
      }
      const touch = event.touches[0];
      touchSwipeStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: performance.now()
      };
    }

    function onTouchEnd(event) {
      if (!touchSwipeStart) return;
      if (event.changedTouches.length !== 1) {
        touchSwipeStart = null;
        return;
      }

      const touch = event.changedTouches[0];
      const dx = touch.clientX - touchSwipeStart.x;
      const dy = touch.clientY - touchSwipeStart.y;
      const dt = performance.now() - touchSwipeStart.time;
      touchSwipeStart = null;

      if (dt > SWIPE_SETTINGS.MAX_DURATION_MS) return;
      if (Math.abs(dx) < SWIPE_SETTINGS.MIN_DISTANCE_PX) return;
      if (Math.abs(dy) > SWIPE_SETTINGS.MAX_OFF_AXIS_PX) return;
      if (Math.abs(dx) <= Math.abs(dy)) return;

      suppressClickUntilTs = Date.now() + SWIPE_SETTINGS.SUPPRESS_CLICK_MS;
      if (dx < 0) {
        void goNextSlide();
      } else {
        void goPrevSlide();
      }
    }

    function onTouchCancel() {
      touchSwipeStart = null;
    }

    if (HAS_TOUCH_INPUT) {
      stageWrap.addEventListener("touchstart", onTouchStart, { passive: true });
      stageWrap.addEventListener("touchend", onTouchEnd, { passive: true });
      stageWrap.addEventListener("touchcancel", onTouchCancel, { passive: true });
    }

    const CURSOR_ARROW_SIZE = 56;
    const CURSOR_ARROW_HOTSPOT = CURSOR_ARROW_SIZE / 2;

    const LEFT_CURSOR = (() => {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${CURSOR_ARROW_SIZE}" height="${CURSOR_ARROW_SIZE}" viewBox="0 0 28 28"><path d="M19 6L9 14L19 22" fill="none" stroke="white" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 6L9 14L19 22" fill="none" stroke="black" stroke-opacity="0.45" stroke-width="5.8" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      return `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${CURSOR_ARROW_HOTSPOT} ${CURSOR_ARROW_HOTSPOT}, w-resize`;
    })();

    const RIGHT_CURSOR = (() => {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${CURSOR_ARROW_SIZE}" height="${CURSOR_ARROW_SIZE}" viewBox="0 0 28 28"><path d="M9 6L19 14L9 22" fill="none" stroke="white" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 6L19 14L9 22" fill="none" stroke="black" stroke-opacity="0.45" stroke-width="5.8" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      return `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${CURSOR_ARROW_HOTSPOT} ${CURSOR_ARROW_HOTSPOT}, e-resize`;
    })();

    function updateDirectionalCursor(clientX, target) {
      if (target instanceof Element && target.closest("#pager")) {
        stageWrap.style.cursor = "default";
        return;
      }
      const rect = stageWrap.getBoundingClientRect();
      const relativeX = clientX - rect.left;
      const isLeftHalf = relativeX < rect.width / 2;
      const canGoPrev = requestedSlideIndex > 0;
      const canGoNext = requestedSlideIndex < slides.length - 1;

      if (isLeftHalf) {
        stageWrap.style.cursor = canGoPrev ? LEFT_CURSOR : "default";
        return;
      }
      stageWrap.style.cursor = canGoNext ? RIGHT_CURSOR : "default";
    }

    function updatePagerVisibility(clientY) {
      const rect = stageWrap.getBoundingClientRect();
      const relativeY = clientY - rect.top;
      const inBottomThird = relativeY >= rect.height * (2 / 3);
      pagerNode.classList.toggle("visible", inBottomThird);
    }

    stageWrap.addEventListener("mouseenter", (event) => {
      updateDirectionalCursor(event.clientX, event.target);
      updatePagerVisibility(event.clientY);
    });

    stageWrap.addEventListener("mousemove", (event) => {
      updateDirectionalCursor(event.clientX, event.target);
      updatePagerVisibility(event.clientY);
    });

    stageWrap.addEventListener("mouseleave", () => {
      stageWrap.style.cursor = "default";
      pagerNode.classList.remove("visible");
    });

    if (downloadPdfButton instanceof HTMLButtonElement) {
      downloadPdfButton.addEventListener("click", (event) => {
        event.stopPropagation();
        void exportSlidesToPdf();
      });
    }

    void start();
  </script>
</body>
</html>
